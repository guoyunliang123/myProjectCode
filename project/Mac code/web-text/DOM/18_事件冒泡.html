<!DOCTYPE html>
<html lang="en" id="html">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        #div1 {
            width: 400px;
            height: 400px;
            background: #ff0000;
        }

        #div2 {
            width: 300px;
            height: 300px;
            background: #00ff00;
        }

        #div3 {
            width: 200px;
            height: 200px;
            background: #ffff00;
        }
    </style>
</head>

<body id="body">
    <div id="div1">
        <div id="div2">
            <div id="div3"></div>
        </div>
    </div>

    <script>
        var oDiv1 = document.getElementById("div1");
        var oDiv2 = document.getElementById("div2");
        var oDiv3 = document.getElementById("div3");
        var oBody = document.getElementById("body");
        var oHtml = document.getElementById("html");




        // oDiv1.onclick = function(){
        //     alert("div1");
        // };
        // oDiv2.onclick = function(){
        //     alert("div2");
        // };
        // oDiv3.onclick = function(){
        //     alert("div3");
        // };
        // oBody.onclick = function(){
        //     alert("body");
        // };
        // oHtml.onclick = function(){
        //     alert("html");
        // };  
        //点击div3弹出顺序： div3  div2  div1  body  html  



        // oDiv1.onclick = function(){
        //     alert("div1");
        // };
        // oDiv1.onclick = function(){
        //     alert("div2");
        // }; 
        //输出结果：div2        相当于 var a = 5； a = 6； 后定义的会给先定义的覆盖掉





        //obj.addEventListener函数不会被覆盖掉，按绑定的顺序去执行。有兼容性问题
        //有三个参数：
        //第一个：要绑定的事件类型，要去掉on
        //第二个：事件的处理函数 
        //第三个：boolean型的数：默认值为false,相当于事件是冒泡的
        // 当为true是，相当于事件捕获
        // oDiv1.addEventListener("click", function(){
        //     alert("1");
        // },  false); 
        // oDiv1.addEventListener("click", function(){
        //     alert("2");
        // }, false);    
        //输出结果：1  2


        // oDiv1.addEventListener("click", function () {
        //     alert("div1");
        // }, false);
        // oDiv2.addEventListener("click", function () {
        //     alert("div2");
        // }, false);
        // oDiv3.addEventListener("click", function () {
        //     alert("div3");
        // }, false);     
        //输出结果：div3 div2 div1   事件冒泡


        // oDiv1.addEventListener("click", function (e) {
        //    console.log(this);//this指向的是所绑定的事件对象
        //     alert("div1");
        //     e.stopPropagation();// 阻止事件冒泡
        // }, false);
        // oDiv2.addEventListener("click", function (e) {
        //     alert("div2");
        //     e.stopPropagation();// 阻止事件冒泡
        // }, false);
        // oDiv3.addEventListener("click", function (e) {
        //     alert("div3");
        //     e.stopPropagation();// 阻止事件冒泡
        // }, false);  


        // oDiv1.addEventListener("click", function () {
        //     alert("div1");
        // }, true);
        // oDiv2.addEventListener("click", function () {
        //     alert("div2");
        // }, true);
        // oDiv3.addEventListener("click", function () {
        //     alert("div3");
        // }, true);  
        //输出结果： div1 div2 div3   事件捕获


        //obj.attachEvent：只支持早期IE。有两个参数
        //第一个参数：要绑定的事件类型，需要些on
        //第二个参数：事件处理方法
        //   oDiv1.attachEvent("onclick", function(){
        //       alert(1);
        //       console.log( this === window )//输出结果为true这里的this指向的是window
        //   });
        //   oDiv1.attachEvent("onclick", function(){
        //       alert(2);
        //   });  //输出结果： 2   1   执行顺序和绑定的顺序是相反的


        // oDiv1.attachEvent("onclick", function () {
        //     alert(1);
        //     window.event.cancelBubble = true;   //阻止IE中事件冒泡 
        // });
        // oDiv2.attachEvent("onclick", function () {
        //     alert(2);
        //     window.event.cancelBubble = true;   //阻止IE中事件冒泡 
        // });
        // oDiv3.attachEvent("onclick", function () {
        //     alert(3);
        //     window.event.cancelBubble = true;   //阻止IE中事件冒泡 
        // });


        //参数：
        //第一个：给谁绑定事件，元素
        //第二个：绑定什么事件，事件类型
        //第三个: 事件处理函数


        //封装函数，解决兼容性问题
        // addEvent(oDiv1, "click", function(){
        //     alert(1);
        // });
        // function addEvent(elem, type, handler){
        //     if(elem.addEventListener){// 能力检测，不需要写()
        //         elem.addEventListener(type, handler);
        //     }else if(elem.attachEvent){
        //         elem.attachEvent("on" + type, handler);
        //     }else{
        //         elem["on" + type] = Headers;    
        //     }
        // }



        // var obj = {
        //     name : "zhangsan",
        //     agr : 20
        // };

        // var p = "name";
        // console.log(obj.p);
        // console.log(obj[p]);

        // for (var p in obj){
        //     console.log(obj[p]);
        // }
        //如果一个属性是固定的，就用对象.属性！或对象[属性]！ 如果这个属性是一个变量，就必须要用对象[属性]!
    </script>
</body>

</html>


<!-- 
事件： 事件源   事件处理函数  事件对象   e || window.event

事件冒泡：浏览器默认是事件冒泡的，可以用addEventListener的第三个参数控制它是事件冒泡还是事件捕获，false是事件冒泡，true是事件捕获
obj.addEventListener(type, function(){   
}, false/true);
默认为false  事件冒泡：从事件源开始一层一层往外传播
true  事件捕获：从外面开始一层层到事件源
事件发生过程：先捕获，后冒泡！！！

IE:attachEvent(on+type, function(){});
在IE中，只支持事件冒泡，不支持事件捕获
缺点：绑定顺序是相反的    this 指向window

阻止事件冒泡：e.stopPropagation();标准浏览器
            window.event.cancelBubble = true;  IE浏览器


事件代理或者事件委托：是利用事件冒泡把子元素的事件统一委托给父元素去绑定
1、子元素事件委托给父元素绑定   事件源： e.target    window.event.srcElement
2、后生成的元素事件绑定问题

 -->